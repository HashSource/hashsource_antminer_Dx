// bad sp value at call has been detected, the output may be wrong!
void __fastcall __noreturn main(int a1, const char **a2, char **a3)
{
  const char *v3; // r8
  FILE *v4; // r9
  size_t v5; // r0
  FILE *v6; // r0
  size_t v7; // r6
  int v8; // r9
  char *v9; // r7
  size_t i; // r5
  const unsigned __int16 **v11; // r0
  int v12; // t1
  int v13; // r3
  int v14; // r6
  int v15; // r0
  int (*v16)(void); // r2
  int (**v17)(void); // r3
  bool v18; // zf
  int v19; // r0
  int v20; // r0
  int v21; // r3
  int v22; // r5
  int v23; // r7
  int v24; // r6
  const char **v25; // r8
  const char *v26; // t1
  int v27; // r0
  int v28; // r6
  const char *v29; // r0
  char *v30; // r0
  char *v31; // r8
  char *v32; // r7
  char *v33; // r0
  size_t v34; // r0
  char *v35; // r12
  char *v36; // r5
  size_t v37; // r0
  unsigned int v38; // r6
  unsigned int v39; // r7
  int v40; // r12
  int v41; // r3
  unsigned __int8 *v42; // r10
  unsigned int v43; // r2
  unsigned __int8 *v44; // r0
  int v45; // r1
  unsigned int v46; // r8
  unsigned int v47; // r12
  int v48; // r3
  unsigned int v49; // r2
  unsigned int v50; // r12
  int v51; // r3
  unsigned int v52; // r7
  unsigned int v53; // r12
  char *v54; // r2
  unsigned int v55; // r12
  int v56; // r3
  unsigned int v57; // r7
  unsigned int v58; // r2
  int v59; // r3
  unsigned int v60; // r1
  unsigned int v61; // r2
  unsigned int v62; // r3
  unsigned int v63; // r6
  size_t v64; // r0
  char *v65; // r3
  int v66; // r7
  int v67; // r3
  char *v68; // r8
  int v69; // r3
  int v70; // r6
  int v71; // r2
  _DWORD *v72; // r2
  int v73; // r1
  int v74; // r3
  _DWORD *v75; // r8
  int v76; // r1
  char *v77; // r9
  __int64 *v78; // r3
  __int64 v79; // r0
  _DWORD *v80; // r7
  _DWORD *v81; // r6
  int v82; // r5
  char *v83; // r2
  unsigned int v84; // r3
  int v85; // r1
  int v86; // r3
  int v87; // r0
  int v88; // r3
  _DWORD *v89; // r3
  unsigned int v90; // r2
  unsigned int v91; // r1
  bool v92; // cc
  int v93; // r2
  int v94; // r3
  int v95; // r0
  int v96; // r6
  int v97; // r0
  char *v98; // r3
  int v99; // r2
  int *v100; // r3
  int v101; // r0
  int v102; // r1
  __int16 v103; // r3
  int v104; // r3
  int v105; // r3
  char *v106; // r9
  int v107; // r5
  char *v108; // r6
  char *v109; // r0
  char *v110; // r1
  int v111; // r5
  const char *v112; // r1
  const char *v113; // r1
  const char *v114; // r5
  const char *v115; // r3
  int v116; // r3
  int v117; // r4
  int v118; // r2
  int v119; // r6
  int v120; // r5
  int v121; // r0
  char *v122; // r0
  int v123; // r9
  unsigned int v124; // r7
  char *j; // r0
  char v126; // r3
  char *v127; // r12
  const char *v128; // r0
  int v129; // r0
  bool v130; // zf
  int v131; // r0
  int v132; // r3
  int v133; // r3
  int v134; // r5
  char *v135; // r7
  int v136; // r0
  int v137; // r3
  int v138; // r3
  char *v139; // r7
  int v140; // r5
  int v141; // r0
  int v142; // r3
  void *v143; // r0
  void **v144; // r9
  void *v145; // r0
  char *v146; // r12
  int *v147; // lr
  int v148; // r0
  int v149; // r1
  int v150; // r2
  int v151; // r3
  _DWORD *v152; // r12
  _DWORD *v153; // lr
  int v154; // r1
  int *v155; // r1
  int v156; // r0
  int v157; // r3
  int v158; // r0
  int v159; // r1
  int v160; // r12
  int v161; // r3
  int v162; // r1
  int v163; // r12
  int k; // r3
  int v165; // r2
  int m; // r6
  _DWORD *v167; // r3
  int v168; // r4
  int v169; // r3
  const char *v170; // r0
  size_t v171; // r5
  size_t v172; // r5
  char *v173; // r0
  const char *v174; // r3
  char *v175; // r6
  __sighandler_t v176; // r4
  __sighandler_t v177; // r0
  bool v178; // zf
  __pid_t v179; // r0
  __pid_t v180; // r4
  int v181; // r0
  int v182; // r0
  int n; // r5
  int v184; // r8
  int *v185; // r8
  int v186; // r4
  int *v187; // r10
  char *v188; // r8
  _DWORD *v189; // r5
  int v190; // r2
  _DWORD *v191; // r0
  _DWORD *v192; // r7
  char *v193; // r6
  char *v194; // r3
  int *v195; // r10
  int *v196; // r9
  char *v197; // r4
  int *v198; // r0
  int v199; // r12
  char *v200; // r1
  int v201; // r0
  int v202; // lr
  int v203; // r5
  int v204; // r5
  int v205; // r3
  int v206; // r3
  int v207; // r5
  int *v208; // r0
  int v209; // r2
  int v210; // r3
  int v211; // r1
  char *v212; // r5
  char *v213; // r4
  pthread_mutex_t *v214; // r0
  int v215; // r3
  int v216; // r0
  int v217; // r0
  int v218; // r1
  int v219; // r3
  _DWORD *v220; // r0
  int v221; // r0
  int v222; // r8
  int v223; // r3
  int v224; // r1
  int v225; // r3
  _DWORD *v226; // r0
  int v227; // r8
  int v228; // r3
  int ii; // r3
  int v230; // r12
  int v231; // r3
  int v232; // r3
  char *v233; // r10
  int v234; // r1
  int v235; // r3
  int v236; // r12
  int v237; // r0
  int v238; // r3
  int v239; // r5
  int jj; // r10
  int v241; // r0
  int v242; // r1
  int v243; // r8
  char *v244; // r1
  _DWORD *v245; // r3
  int v246; // r3
  const char *v247; // lr
  char *v248; // r12
  int v249; // r0
  int v250; // r1
  int v251; // r2
  int v252; // r3
  _DWORD *v253; // lr
  _DWORD *v254; // r12
  int v255; // r1
  int v256; // r2
  int kk; // r3
  int v258; // r12
  int v259; // r3
  int mm; // r3
  int v261; // r3
  int v262; // r10
  int v263; // r1
  int v264; // r3
  int v265; // r0
  int v266; // r0
  int nn; // r10
  int v268; // r0
  int v269; // r1
  int v270; // r1
  int *v271; // r0
  int v272; // r10
  int v273; // r8
  _DWORD *v274; // r3
  int *v275; // r0
  int v276; // r0
  int v277; // r1
  int v278; // r3
  int v279; // r12
  int v280; // r4
  int v281; // r3
  const char **v282; // r8
  int v283; // r7
  int v284; // r3
  pthread_mutex_t *v285; // r0
  int v286; // r7
  int *v287; // r0
  int *v288; // r0
  int i1; // r4
  char v290; // [sp+10h] [bp-2A34h] BYREF
  char v291[4088]; // [sp+1018h] [bp-1A2Ch] BYREF
  const char *v292; // [sp+2010h] [bp-A34h]
  int *v293; // [sp+2020h] [bp-A24h]
  char *v294; // [sp+2024h] [bp-A20h]
  char *v295; // [sp+2028h] [bp-A1Ch]
  int *v296; // [sp+202Ch] [bp-A18h]
  int v297; // [sp+2030h] [bp-A14h]
  __int16 *v298; // [sp+2034h] [bp-A10h]
  int *v299; // [sp+2038h] [bp-A0Ch]
  char *v300; // [sp+203Ch] [bp-A08h]
  char *v301; // [sp+2040h] [bp-A04h]
  int *v302; // [sp+2044h] [bp-A00h]
  char *v303; // [sp+2048h] [bp-9FCh]
  char *v304; // [sp+204Ch] [bp-9F8h]
  char *format; // [sp+2050h] [bp-9F4h]
  const char **v306; // [sp+2054h] [bp-9F0h]
  int v307; // [sp+2058h] [bp-9ECh]
  int v308; // [sp+205Ch] [bp-9E8h] BYREF
  int v309; // [sp+2060h] [bp-9E4h] BYREF
  char dest[32]; // [sp+2064h] [bp-9E0h] BYREF
  struct sigaction s; // [sp+2084h] [bp-9C0h] BYREF
  char v312[256]; // [sp+2110h] [bp-934h] BYREF
  int v313[513]; // [sp+2210h] [bp-834h] BYREF

  byte_68AAC = 0;
  v308 = a1;
  v3 = *a2;
  v306 = a2;
  v302 = (int *)&byte_68AAC;
  v309 = 0;
  memset(v312, 0, sizeof(v312));
  memset(&s, 0, 0x40u);
  snprintf((char *)&s, 0x40u, "pidof %s", v3);
  v4 = popen((const char *)&s, "r");
  if ( v4 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        do
        {
          if ( !fgets(v312, 256, v4) )
          {
            v6 = v4;
            v7 = 0;
            v8 = 0;
            pclose(v6);
            v9 = v312;
            for ( i = 1; strlen(v312) >= i; ++i )
            {
              memset(dest, 0, sizeof(dest));
              v11 = _ctype_b_loc();
              v12 = (unsigned __int8)*v9++;
              if ( ((*v11)[v12] & 0x2000) != 0 )
              {
                strncpy(dest, &v312[v7], i - v7 - 1);
                v13 = strtol(dest, 0, 10);
                if ( v13 > 0 && (++v8, byte_68BD5) && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
                {
                  snprintf((char *)v313, 0x800u, "Parsed proc id is: %d\n", v13);
                  v7 = i;
                  sub_20F58(7, v313, 0);
                }
                else
                {
                  v7 = i;
                }
              }
            }
            if ( v8 )
            {
              if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
              {
                snprintf((char *)v313, 0x800u, " %d instance of %s is  already Running on this machine", v8, v3);
                sub_20F58(3, v313, 0);
              }
              if ( v8 != 1 )
              {
                snprintf((char *)v313, 0x800u, "%s is forbidden to start twice, will exit immediately!", *v306);
                sub_20F58(3, v313, 1);
                sub_2E6B0(-1, 0);
              }
            }
            goto LABEL_34;
          }
        }
        while ( !byte_68BD5 );
        if ( byte_74500 || byte_68BD4 || dword_67DB4 > 6 )
          break;
LABEL_9:
        if ( byte_68BD4 || dword_67DB4 > 6 )
        {
LABEL_11:
          v5 = strlen(v312);
          snprintf((char *)v313, 0x800u, "strlen is: %d\n", v5);
          sub_20F58(7, v313, 0);
        }
      }
      snprintf((char *)v313, 0x800u, "pidof %s command result is: %s\n", v3, v312);
      sub_20F58(7, v313, 0);
      if ( byte_68BD5 )
      {
        if ( byte_74500 )
          goto LABEL_11;
        goto LABEL_9;
      }
    }
  }
  if ( byte_68BD5 && (byte_74500 || byte_68BD4 || dword_67DB4 > 6) )
  {
    snprintf((char *)v313, 0x800u, " app-service:%s Not Found!!!", v3);
    sub_20F58(7, v313, 0);
  }
LABEL_34:
  strcpy((char *)&dword_68AD4, "bmminer.log");
  strcpy((char *)&word_68AB4, "a+");
  v300 = (char *)&word_68AB4;
  LOWORD(v14) = (unsigned __int16)&unk_68BD8;
  v15 = sysconf(84);
  v18 = v15 == 1;
  if ( v15 == 1 )
  {
    v17 = &off_67ED8;
    v16 = sched_yield;
  }
  v19 = v308 + 1;
  if ( v18 )
    *v17 = v16;
  HIWORD(v14) = (unsigned int)&unk_68BD8 >> 16;
  v307 = v14;
  v20 = sub_229BC(4 * v19, "cgminer.c", "main", 11819);
  v21 = v308;
  v22 = v20;
  *(_DWORD *)(v14 + 0x47C) = v20;
  if ( v21 > 0 )
  {
    v23 = v20 - 4;
    v24 = 0;
    v25 = v306 - 1;
    do
    {
      v26 = v25[1];
      ++v25;
      ++v24;
      *(_DWORD *)(v23 + 4) = _strdup(v26);
      v23 += 4;
      v21 = v308;
    }
    while ( v308 > v24 );
  }
  *(_DWORD *)(v22 + 4 * v21) = 0;
  sub_2EE90(&unk_76838, "main", 11828);
  sub_2EE90(&unk_767C8, "main", 11829);
  sub_2EE90(&unk_766E4, "main", 11830);
  sub_2EF3C(&unk_7453C, "main", 11831);
  sub_2EE90(&unk_766C4, "main", 11832);
  v304 = (char *)&unk_6ABD0;
  sub_2EE90(&stru_6918C, "main", 11833);
  sub_2EF3C(&unk_74504, "main", 11834);
  sub_2EE90(&stru_690F0, "main", 11835);
  sub_2EF14(&stru_6A6C0, "main", 11836);
  sub_2EF14(&unk_755A0, "main", 11837);
  sub_2EF14(&stru_744A8, "main", 11838);
  sub_2EF14(&stru_7680C, "main", 11839);
  sub_2EE90(&stru_6910C, "main", 11841);
  if ( pthread_cond_init(&cond, 0) )
  {
    strcpy((char *)v313, "Failed to pthread_cond_init lp_cond");
    sub_20F58(3, v313, 1);
    sub_2E6B0(1, 0);
  }
  sub_2EE90(&unk_767F4, "main", 11848);
  if ( pthread_cond_init(&stru_76700, 0) )
  {
    strcpy((char *)v313, "Failed to pthread_cond_init restart_cond");
    sub_20F58(3, v313, 1);
    sub_2E6B0(1, 0);
  }
  v301 = (char *)pthread_cond_init(&stru_744D0, 0);
  if ( v301 )
  {
    strcpy((char *)v313, "Failed to pthread_cond_init gws_cond");
    sub_20F58(3, v313, 1);
    sub_2E6B0(1, 0);
  }
  v27 = sub_23300();
  dword_755E0 = v27;
  if ( !v27 )
  {
    strcpy((char *)v313, "Failed to create getq");
    sub_20F58(3, v313, 1);
    sub_2E6B0(1, 0);
  }
  v292 = (const char *)&unk_55AA8;
  *(_DWORD *)(v307 + 0x438) = v27 + 12;
  snprintf(::s, 0x100u, "%s %s", "cgminer", v292);
  s.sa_handler = (__sighandler_t)sub_2E78C;
  s.sa_flags = (int)v301;
  v299 = &dword_755C4;
  sigemptyset(&s.sa_mask);
  sigaction(15, &s, &stru_755F8);
  sigaction(2, &s, &stru_76730);
  sigaction(6, &s, &stru_733D0);
  dword_755C4 = (int)v291;
  strcpy(v291, "/usr/bin");
  v28 = 36;
  dword_7557C = (int)&v290;
  v29 = *v306;
  v298 = &word_51DD8;
  v30 = _strdup(v29);
  v31 = (char *)dword_7557C;
  v32 = v30;
  v33 = dirname(v30);
  strcpy(v31, v33);
  free(v32);
  v34 = strlen((const char *)dword_7557C);
  v35 = v304;
  *(_WORD *)(dword_7557C + v34) = 47;
  *(_DWORD *)&v35[-644] = 9;
  v36 = (char *)sub_22A44(104, 1, "cgminer.c", "main", 11895);
  do
  {
    v37 = strlen(v36);
    --v28;
    *(_WORD *)&v36[v37] = 48;
  }
  while ( v28 );
  v38 = v37 + 1;
  v39 = -1640531527;
  v40 = -17973521;
  format = (char *)(v37 + 1);
  v41 = -1640531527;
  if ( v37 + 1 <= 0xB )
  {
    v44 = (unsigned __int8 *)v36;
    v54 = format;
  }
  else
  {
    v42 = (unsigned __int8 *)(v36 + 12);
    v303 = v36;
    do
    {
      v38 -= 12;
      v43 = (*(v42 - 6) << 16) + (*(v42 - 7) << 8) + *(v42 - 8) + (*(v42 - 5) << 24) + v39;
      v44 = v42;
      v45 = (*(v42 - 2) << 16) + (*(v42 - 3) << 8) + *(v42 - 4) + (*(v42 - 1) << 24);
      v46 = (*(v42 - 10) << 16) + (*(v42 - 11) << 8) + *(v42 - 12) + (*(v42 - 9) << 24) - v43;
      v42 += 12;
      v47 = v45 + v40;
      v48 = (v46 - v47 + v41) ^ (v47 >> 13);
      v49 = (v43 - v47 - v48) ^ (v48 << 8);
      v50 = (v47 - v48 - v49) ^ (v49 >> 13);
      v51 = (v48 - v49 - v50) ^ (v50 >> 12);
      v52 = (v49 - v50 - v51) ^ (v51 << 16);
      v53 = (v50 - v51 - v52) ^ (v52 >> 5);
      v41 = (v51 - v52 - v53) ^ (v53 >> 3);
      v39 = (v52 - v53 - v41) ^ (v41 << 10);
      v40 = (v53 - v41 - v39) ^ (v39 >> 15);
    }
    while ( v38 > 0xB );
    v36 = v303;
    v54 = (char *)v38;
  }
  v55 = (unsigned int)&format[v40];
  switch ( (unsigned int)v54 )
  {
    case 1u:
      goto LABEL_62;
    case 2u:
      goto LABEL_61;
    case 3u:
      goto LABEL_60;
    case 4u:
      goto LABEL_59;
    case 5u:
      goto LABEL_58;
    case 6u:
      goto LABEL_57;
    case 7u:
      goto LABEL_56;
    case 8u:
      goto LABEL_55;
    case 9u:
      goto LABEL_54;
    case 0xAu:
      goto LABEL_53;
    case 0xBu:
      v55 += v44[10] << 24;
LABEL_53:
      v55 += v44[9] << 16;
LABEL_54:
      v55 += v44[8] << 8;
LABEL_55:
      v39 += v44[7] << 24;
LABEL_56:
      v39 += v44[6] << 16;
LABEL_57:
      v39 += v44[5] << 8;
LABEL_58:
      v39 += v44[4];
LABEL_59:
      v41 += v44[3] << 24;
LABEL_60:
      v41 += v44[2] << 16;
LABEL_61:
      v41 += v44[1] << 8;
LABEL_62:
      v41 += *v44;
      break;
    default:
      break;
  }
  *((_DWORD *)v36 + 22) = v36;
  v56 = (v41 - v39 - v55) ^ (v55 >> 13);
  v57 = (v39 - v55 - v56) ^ (v56 << 8);
  v58 = (v55 - v56 - v57) ^ (v57 >> 13);
  v59 = (v56 - v57 - v58) ^ (v58 >> 12);
  v60 = (v57 - v58 - v59) ^ (v59 << 16);
  v61 = (v58 - v59 - v60) ^ (v60 >> 5);
  v62 = v59 - v60 - v61;
  v63 = (v61 - (v62 ^ (v61 >> 3)) - ((v60 - v61 - (v62 ^ (v61 >> 3))) ^ ((v62 ^ (v61 >> 3)) << 10)))
      ^ (((v60 - v61 - (v62 ^ (v61 >> 3))) ^ ((v62 ^ (v61 >> 3)) << 10)) >> 15);
  *((_DWORD *)v36 + 24) = v63;
  v64 = strlen(v36);
  v65 = v304;
  *((_DWORD *)v36 + 23) = v64;
  v66 = *(_DWORD *)&v65[-1264];
  if ( v66 )
  {
    v67 = *(_DWORD *)(v66 + 68);
    *((_DWORD *)v36 + 19) = 0;
    v68 = v36 + 68;
    *((_DWORD *)v36 + 17) = v67;
    *((_DWORD *)v36 + 18) = *(_DWORD *)(*(_DWORD *)(v66 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v66 + 68) + 20);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v66 + 68) + 16) + 8) = v36;
    *(_DWORD *)(*(_DWORD *)(v66 + 68) + 16) = v36 + 68;
  }
  else
  {
    *((_DWORD *)v36 + 19) = 0;
    *((_DWORD *)v36 + 18) = 0;
    *(_DWORD *)&v65[-1264] = v36;
    v143 = malloc(0x2Cu);
    *((_DWORD *)v36 + 17) = v143;
    if ( !v143 )
      goto LABEL_184;
    memset(v143, 0, 0x2Cu);
    v68 = v36 + 68;
    *(_DWORD *)(*((_DWORD *)v36 + 17) + 16) = v36 + 68;
    *(_DWORD *)(*((_DWORD *)v36 + 17) + 4) = 32;
    *(_DWORD *)(*((_DWORD *)v36 + 17) + 8) = 5;
    *(_DWORD *)(*((_DWORD *)v36 + 17) + 20) = 68;
    v144 = (void **)*((_DWORD *)v36 + 17);
    *v144 = malloc(0x180u);
    v145 = (void *)**((_DWORD **)v36 + 17);
    if ( !v145 )
      goto LABEL_184;
    memset(v145, 0, 0x180u);
    *(_DWORD *)(*((_DWORD *)v36 + 17) + 40) = -1609490463;
  }
  v69 = *(_DWORD *)&v304[-1264];
  ++*(_DWORD *)(*(_DWORD *)(v69 + 68) + 12);
  v70 = 12 * (v63 & (*(_DWORD *)(*(_DWORD *)(v69 + 68) + 4) - 1));
  ++*(_DWORD *)(**(_DWORD **)(v69 + 68) + v70 + 4);
  v71 = *(_DWORD *)(**(_DWORD **)(v69 + 68) + v70);
  *((_DWORD *)v36 + 20) = 0;
  *((_DWORD *)v36 + 21) = v71;
  v72 = *(_DWORD **)(v69 + 68);
  v73 = *(_DWORD *)(*v72 + v70);
  if ( v73 )
  {
    *(_DWORD *)(v73 + 12) = v68;
    v72 = *(_DWORD **)(v69 + 68);
  }
  *(_DWORD *)(*v72 + v70) = v68;
  if ( *(_DWORD *)(**(_DWORD **)(v69 + 68) + v70 + 4) < (unsigned int)(10
                                                                     * *(_DWORD *)(**(_DWORD **)(v69 + 68) + v70 + 8)
                                                                     + 10)
    || (v74 = *((_DWORD *)v36 + 17), *(_DWORD *)(v74 + 36) == 1) )
  {
LABEL_86:
    strcpy(byte_73324, v36);
    dword_767C0 = (int)&dword_767C0;
    dword_767C4 = (int)&dword_767C0;
    sub_409F8(&off_67FE0, "Options for both config file and command line");
    sub_409F8(&off_68760, "Options for command line only");
    v95 = sub_40ACC(&v308, v306, sub_2AA90);
    if ( v308 != 1 )
    {
      qmemcpy(v313, "Unexpected extra commandline arguments", 38);
      v126 = aUnexpectedExtr[38];
      v127 = (char *)&v313[9] + 2;
      goto LABEL_142;
    }
    if ( !*(_BYTE *)(v307 + 0x324) )
      v95 = sub_2D8F0(v95);
    v18 = *(_BYTE *)(v307 + 0x5A4) == 0;
    v303 = (char *)&dword_766C0;
    if ( !v18 || dword_766C0 )
    {
      v96 = sub_324B8();
      v97 = sub_229BC(255, "cgminer.c", "main", 11931);
      v98 = v303;
      v99 = v97;
      *(_DWORD *)(v96 + 164) = v97;
      if ( *(_DWORD *)v98 )
        LOWORD(v100) = 16788;
      else
        LOWORD(v100) = 16800;
      HIWORD(v100) = 5;
      v101 = *v100;
      v102 = v100[1];
      v103 = *((_WORD *)v100 + 4);
      *(_DWORD *)v99 = v101;
      *(_DWORD *)(v99 + 4) = v102;
      *(_WORD *)(v99 + 8) = v103;
      v104 = *(_DWORD *)(v96 + 164);
      *(_DWORD *)(v96 + 172) = v104;
      *(_DWORD *)(v96 + 176) = v104;
      *(_DWORD *)(v96 + 168) = v104;
      *(_DWORD *)(v96 + 600) = v104;
      strncpy((char *)(v96 + 48), "?", 7u);
      v105 = *(_DWORD *)(v96 + 100);
      *(_BYTE *)(v96 + 55) = 0;
      if ( v105 != 1 )
        sub_2B664(v96 + 100);
      v106 = (char *)&unk_691B0;
      v107 = 0;
      *(_BYTE *)(v96 + 97) = 0;
      v108 = (char *)&unk_69BB0;
      byte_68BD6 = 1;
      do
      {
        v109 = v106;
        v106 += 160;
        sub_22CD8(v109, &a000000029c6bf4[v107]);
        v110 = &a00000002c01f50[v107];
        v107 += 324;
        sub_22CD8(v108, v110);
        v108 += 160;
      }
      while ( v107 != 5184 );
      v95 = sub_2D950(&unk_6A950);
    }
    if ( *(_DWORD *)(v307 + 0x210) )
      sub_3FB54(v95);
    v111 = v307;
    v112 = *(const char **)(v307 + 0x200);
    if ( v112 )
    {
      *(_BYTE *)v302 = 1;
      strcpy((char *)&dword_68AD4, v112);
      v113 = *(const char **)(v111 + 0x20C);
      if ( v113 )
        strcpy((char *)&word_68AB4, v113);
      if ( !byte_74500 )
      {
        v306 = (const char **)&byte_68BD4;
        if ( !byte_68BD4 && dword_67DB4 <= 2 )
        {
          v114 = *(const char **)(v307 + 0x208);
          if ( !v114 )
          {
LABEL_109:
            if ( dword_67DB4 <= 3 )
            {
              v115 = *(const char **)(v307 + 0x31C);
              if ( !v115 )
                goto LABEL_120;
LABEL_111:
              if ( dword_67DB4 <= 4 )
              {
                v116 = *(_DWORD *)(v307 + 0x3F0);
                if ( v116 != -1 )
                  goto LABEL_113;
LABEL_205:
                if ( !*(_BYTE *)v306 && dword_67DB4 <= 3 )
                {
                  if ( !byte_74488 )
                    goto LABEL_119;
                  goto LABEL_208;
                }
LABEL_210:
                strcpy((char *)v313, "Error in configuration file, partially loaded.");
                sub_20F58(4, v313, 0);
                if ( !byte_74488 )
                  goto LABEL_119;
                if ( byte_74500 || *(_BYTE *)v306 )
                  goto LABEL_209;
LABEL_208:
                if ( dword_67DB4 > 3 )
                {
LABEL_209:
                  strcpy((char *)v313, "Start cgminer with -T to see what failed to load.");
                  sub_20F58(4, v313, 0);
                }
LABEL_119:
                v117 = v307;
                free(*(void **)(v307 + 0x31C));
                *(_DWORD *)(v117 + 0x31C) = 0;
                goto LABEL_120;
              }
LABEL_112:
              snprintf((char *)v313, 0x800u, "Loaded configuration file %s", v115);
              sub_20F58(5, v313, 0);
              v116 = *(_DWORD *)(v307 + 0x3F0);
              if ( v116 != -1 )
              {
LABEL_113:
                if ( !v116 )
                {
                  if ( (byte_74500 || *(_BYTE *)v306 || dword_67DB4 > 3)
                    && ((strcpy((char *)v313, "Fatal JSON error in configuration file."),
                         sub_20F58(4, v313, 0),
                         byte_74500)
                     || *(_BYTE *)v306)
                    || dword_67DB4 > 3 )
                  {
                    strcpy((char *)v313, "Configuration file could not be used.");
                    sub_20F58(4, v313, 0);
                  }
                }
                goto LABEL_119;
              }
              if ( byte_74500 )
                goto LABEL_210;
              goto LABEL_205;
            }
LABEL_178:
            snprintf((char *)v313, 0x800u, "Started %s", ::s);
            sub_20F58(4, v313, 0);
            v115 = *(const char **)(v307 + 0x31C);
            if ( !v115 )
            {
LABEL_120:
              *(_WORD *)(*v299 + strlen((const char *)*v299)) = *v298;
              if ( byte_73388 )
              {
                *(_BYTE *)v306 = 1;
              }
              else if ( !*(_BYTE *)v306 )
              {
                setlogmask(63);
                goto LABEL_123;
              }
              setlogmask(255);
LABEL_123:
              v118 = dword_68754;
              if ( dword_68754 < 0 )
                v118 = 60;
              LOWORD(v119) = (unsigned __int16)&unk_731F0;
              if ( dword_68754 < 0 )
                dword_68754 = v118;
              *(_DWORD *)&v304[-76] = 8;
              HIWORD(v119) = (unsigned int)&unk_731F0 >> 16;
              v302 = &dword_75598;
              dword_75598 = sub_22A44(8, 64, "cgminer.c", "main", 12093);
              sub_3ECA0(&unk_73268);
              sub_3ECA0(v119);
              sub_3ECA0(&unk_73110);
              format = (char *)&dword_75588;
              sub_3ECA0(&unk_689C8);
              off_73274(0);
              (*(void (__fastcall **)(_DWORD))(v119 + 0xC))(0);
              ((void (__fastcall *)(_DWORD))off_7311C)(0);
              v120 = 0;
              ((void (__fastcall *)(_DWORD))off_689D4)(0);
              dword_75588 = 0;
              while ( dword_755C0 > v120 )
              {
                v121 = *(_DWORD *)(dword_7346C + 4 * v120++);
                sub_3EEE8(v121);
              }
              if ( dword_755C0 )
              {
                v122 = *(char **)(v307 + 0x3FC);
                *(_DWORD *)&v304[-1160] = dword_755C0;
                if ( v122 )
                {
                  v123 = 0;
                  v124 = 0;
                  for ( j = strtok(v122, ","); j; j = strtok(v300, ",") )
                  {
                    if ( dword_755C0 <= v123 )
                    {
                      strcpy((char *)v313, "Too many values passed to set temp cutoff");
                      sub_20F58(3, v313, 1);
                      sub_2E6B0(1, 1);
                    }
                    v124 = strtol(j, 0, 10);
                    if ( v124 > 0xC8 )
                    {
                      v146 = "ssed to set temp cutoff";
                      qmemcpy(v313, "Invalid value pa", 16);
                      v147 = &v313[4];
                      goto LABEL_188;
                    }
                    if ( pthread_rwlock_rdlock(&stru_7680C) )
                      sub_30138("load_temp_cutoffs", 1336);
                    *(_DWORD *)(*(_DWORD *)(dword_7346C + 4 * v123) + 184) = v124;
                    if ( pthread_rwlock_unlock(&stru_7680C) )
                    {
                      v208 = _errno_location();
                      snprintf(
                        (char *)v313,
                        0x800u,
                        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                        *v208,
                        "cgminer.c",
                        "load_temp_cutoffs",
                        1338);
                      v155 = v313;
                      goto LABEL_189;
                    }
                    ++v123;
                    v300 = 0;
                    off_67ED8();
                  }
                  if ( v123 <= 1 )
                  {
                    if ( pthread_rwlock_rdlock(&stru_7680C) )
                      sub_30138("load_temp_cutoffs", 1359);
                    v209 = dword_755C0;
                    v298 = (__int16 *)&dword_7346C;
                    v210 = dword_7346C;
                    while ( v123 < v209 )
                    {
                      v211 = *(_DWORD *)(v210 + 4 * v123++);
                      *(_DWORD *)(v211 + 184) = v124;
                    }
                    sub_2FB80(&stru_7680C, "load_temp_cutoffs", 1365);
                  }
                  else
                  {
                    v298 = (__int16 *)&dword_7346C;
                  }
                }
                else
                {
                  v158 = pthread_rwlock_rdlock(&stru_7680C);
                  if ( v158 )
                    sub_30138("load_temp_cutoffs", 1343);
                  v159 = dword_755C0;
                  v298 = (__int16 *)&dword_7346C;
                  v160 = dword_7346C;
                  while ( v158 < v159 )
                  {
                    v161 = *(_DWORD *)(v160 + 4 * v158++);
                    if ( !*(_DWORD *)(v161 + 184) )
                      *(_DWORD *)(v161 + 184) = 95;
                  }
                  sub_2FB80(&stru_7680C, "load_temp_cutoffs", 1352);
                }
                v162 = dword_755C0;
                v163 = *(_DWORD *)v298;
                for ( k = 0; v162 > k; ++k )
                {
                  v165 = *(_DWORD *)(v163 + 4 * k);
                  *(_DWORD *)(v165 + 312) = 99999999;
                }
                if ( !byte_756B0 )
                  *(_DWORD *)&v304[-644] += *(_DWORD *)&v304[-1160];
                if ( !dword_733CC )
                {
                  if ( byte_74500 || *(_BYTE *)v306 || dword_67DB4 > 3 )
                  {
                    strcpy((char *)v313, "Need to specify at least one pool server.");
                    sub_20F58(4, v313, 0);
                  }
                  strcpy((char *)v313, "Pool setup failed");
                  sub_20F58(3, v313, 1);
                  sub_2E6B0(1, 0);
                }
                v300 = (char *)&dword_744C8;
                v299 = (int *)"cgminer.c";
                for ( m = 0; ; ++m )
                {
                  v167 = *(_DWORD **)v300;
                  if ( dword_733CC <= m )
                    break;
                  v168 = v167[m];
                  v169 = *(_DWORD *)(v168 + 168);
                  *(_DWORD *)(v168 + 404) = 99999999;
                  *(_DWORD *)(v168 + 440) = 99999999;
                  if ( !v169 )
                  {
                    if ( !*(_DWORD *)(v168 + 176) )
                      *(_DWORD *)(v168 + 176) = calloc(1u, 1u);
                    v170 = *(const char **)(v168 + 172);
                    if ( !v170 )
                    {
                      snprintf(
                        (char *)v313,
                        0x800u,
                        "No login credentials supplied for pool %u %s",
                        m,
                        *(const char **)(v168 + 164));
                      sub_20F58(3, v313, 1);
                      sub_2E6B0(1, 0);
                    }
                    v171 = strlen(v170);
                    v172 = v171 + strlen(*(const char **)(v168 + 176)) + 2;
                    v173 = (char *)sub_229BC(v172, v299, "main", 12203);
                    v174 = *(const char **)(v168 + 176);
                    *(_DWORD *)(v168 + 168) = v173;
                    snprintf(v173, v172, "%s:%s", *(const char **)(v168 + 172), v174);
                  }
                }
                v18 = byte_74500 == 0;
                *(_DWORD *)(v307 + 0x488) = *v167;
                if ( !v18 )
                  openlog("cgminer", 1, 8);
                v175 = (char *)v313;
                if ( *(_DWORD *)&v304[-72] )
                {
                  if ( pipe(v313) < 0 )
                  {
                    perror("pipe - failed to create pipe for --monitor");
                    exit(1);
                  }
                  fflush((FILE *)stderr);
                  if ( dup2(v313[1], 2) < 0 )
                  {
                    perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
                    exit(1);
                  }
                  if ( close(v313[1]) < 0 )
                  {
                    perror("close - failed to close write end of pipe for --monitor");
                    exit(1);
                  }
                  v176 = signal(13, (__sighandler_t)1);
                  v177 = signal(13, (__sighandler_t)1);
                  v178 = (__sighandler_t)((char *)v176 + 1) == 0;
                  if ( v176 != (__sighandler_t)-1 )
                    v178 = (__sighandler_t)((char *)v177 + 1) == 0;
                  if ( v178 )
                  {
                    perror("signal - failed to edit signal mask for --monitor");
                    exit(1);
                  }
                  v179 = fork();
                  v180 = v179;
                  *(_DWORD *)(v307 + 0x424) = v179;
                  if ( v179 < 0 )
                  {
                    perror("fork - failed to fork child process for --monitor");
                    exit(1);
                  }
                  if ( !v179 )
                  {
                    if ( dup2(v313[0], v179) >= 0 )
                    {
                      close(v313[0]);
                      execl("/bin/bash", "/bin/bash", "-c", *(_DWORD *)&v304[-72], v180);
                      perror("execl - in child failed to exec user specified command for --monitor");
                      exit(1);
                    }
                    perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
                    exit(1);
                  }
                  if ( close(v313[0]) < 0 )
                  {
                    perror("close - failed to close read end of pipe for --monitor");
                    exit(1);
                  }
                }
                v181 = *(_DWORD *)format;
                v296 = &dword_744A4;
                v182 = sub_22A44(v181, 4, "cgminer.c", "main", 12220);
                dword_744A4 = v182;
                v299 = &dword_755C0;
                for ( n = 0; *(_DWORD *)format > n; ++n )
                {
                  v184 = *v296;
                  v182 = sub_22A44(1, 64, "cgminer.c", "main", 12224);
                  *(_DWORD *)(v184 + 4 * n) = v182;
                }
                v185 = v299;
                v297 = 0;
                v299 = 0;
                v294 = &byte_68BD5;
                v295 = &byte_74500;
                v293 = &dword_733CC;
                while ( *v185 > v297 )
                {
                  v186 = 0;
                  v187 = v185;
                  v188 = v175;
                  v189 = *(_DWORD **)(*(_DWORD *)v298 + 4 * v297);
                  v182 = sub_229BC(4 * (v189[37] + 1), "cgminer.c", "main", 12233);
                  v190 = v189[37];
                  v189[38] = v182;
                  *(_DWORD *)(v182 + 4 * v190) = 0;
                  v189[24] = 4;
                  while ( 1 )
                  {
                    v193 = (char *)v299 + v186;
                    if ( v189[37] <= v186 )
                      break;
                    v191 = (_DWORD *)sub_31B04((char *)v299 + v186);
                    *v191 = v193;
                    v192 = v191;
                    v191[9] = v189;
                    v191[1] = v186;
                    v182 = (*(int (**)(void))(v189[1] + 44))();
                    if ( v182 )
                    {
                      v182 = sub_25164(v192, 0, sub_2B500);
                      if ( v182 )
                      {
                        snprintf(v188, 0x800u, "thread %d create failed", *v192);
                        sub_20F58(3, v188, 1);
                        sub_2E6B0(1, 0);
                      }
                      *(_DWORD *)(v189[38] + 4 * v186) = v192;
                      if ( v189[8] != 1 )
                      {
                        if ( *v294 && (*v295 || *(_BYTE *)v306 || dword_67DB4 > 6) )
                        {
                          snprintf(v188, 0x800u, "Pushing sem post to thread %d", *v192);
                          sub_20F58(7, v188, 0);
                        }
                        v182 = sub_251AC(v192 + 4, "cgminer.c", "main", 12261);
                      }
                    }
                    ++v186;
                  }
                  v194 = v188;
                  v185 = v187;
                  v175 = v194;
                  v299 = (int *)((char *)v299 + v186);
                  ++v297;
                }
                v195 = (int *)v295;
                v196 = v293;
                if ( *(_BYTE *)(v307 + 0x5A4) || (v197 = *(char **)v303) != 0 )
                {
LABEL_284:
                  v198 = (int *)&unk_69088;
                  dbl_756A8 = 0.0;
                  do
                  {
                    *(_QWORD *)v198 = 0;
                    v198 += 2;
                  }
                  while ( &dword_690E8 != v198 );
                  v199 = *v185;
                  v200 = v301;
                  v201 = *(_DWORD *)v298;
                  *(_DWORD *)(v307 + 0x510) = 0;
                  while ( v199 > (int)v200 )
                  {
                    v202 = *(_DWORD *)(v201 + 4 * (_DWORD)v200++);
                    *(_QWORD *)(v202 + 80) = 0;
                    *(_QWORD *)(v202 + 48) = 0;
                  }
                  sub_239A4(&dword_69020);
                  sub_239A4(&dword_69018);
                  sub_239A4(&unk_6907C);
                  sub_2C610(&unk_69028, 40);
                  v203 = *v302;
                  *(_DWORD *)(v307 + 0x480) = 2;
                  if ( sub_25164(v203 + 128, 0, sub_34DF4) )
                  {
                    strcpy(v175, "watchpool thread create failed");
                    sub_20F58(3, v175, 1);
                    sub_2E6B0(1, 0);
                  }
                  pthread_detach(*(_DWORD *)(v203 + 140));
                  v204 = *v302;
                  *(_DWORD *)(v307 + 0x484) = 3;
                  if ( sub_25164(v204 + 192, 0, sub_38D3C) )
                  {
                    strcpy(v175, "watchdog thread create failed");
                    sub_20F58(3, v175, 1);
                    sub_2E6B0(1, 0);
                  }
                  pthread_detach(*(_DWORD *)(v204 + 204));
                  v205 = *v302;
                  *(_DWORD *)(v307 + 0x3F4) = 5;
                  if ( sub_25164(v205 + 320, 0, 180644) )
                  {
                    strcpy(v175, "API thread create failed");
                    sub_20F58(3, v175, 1);
                    sub_2E6B0(1, 0);
                  }
                  v206 = *(_DWORD *)&v304[-76];
                  if ( v206 != 8 )
                  {
                    snprintf(v175, 0x800u, "incorrect total_control_threads (%d) should be 8", v206);
                    sub_20F58(3, v175, 1);
                    sub_2E6B0(1, 0);
                  }
                  if ( !nice(-10) && byte_68BD5 && (*(_BYTE *)v195 || *(_BYTE *)v306 || dword_67DB4 > 6) )
                  {
                    strcpy(v175, "Unable to set thread to high priority");
                    sub_20F58(7, v175, 0);
                  }
                  v212 = v300;
                  v213 = v304;
                  v301 = &byte_767F0;
                  v302 = v195;
                  v304 = &byte_755D4;
                  while ( 1 )
                  {
                    if ( *v301 )
                    {
                      if ( *(_BYTE *)v302 || *(_BYTE *)v306 || dword_67DB4 > 5 )
                      {
                        strcpy(v175, "Work update message received");
                        sub_20F58(6, v175, 0);
                      }
                      sub_239A4(&unk_68FE0);
                      v276 = pthread_rwlock_rdlock(&stru_744A8);
                      if ( v276 )
                      {
                        v287 = _errno_location();
                        snprintf(
                          v175,
                          0x800u,
                          "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
                          *v287,
                          "cgminer.c",
                          "signal_work_update",
                          5507);
                        goto LABEL_423;
                      }
                      v277 = *(_DWORD *)format;
                      v278 = *v296;
                      while ( v276 < v277 )
                      {
                        v279 = *(_DWORD *)(v278 + 4 * v276++);
                        *(_BYTE *)(v279 + 63) = 1;
                      }
                      if ( pthread_rwlock_unlock(&stru_744A8) )
                      {
                        v288 = _errno_location();
                        snprintf(
                          v175,
                          0x800u,
                          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                          *v288,
                          "cgminer.c",
                          "signal_work_update",
                          5514);
LABEL_423:
                        v155 = (int *)v175;
LABEL_189:
                        sub_20F58(3, v155, 1);
                        sub_2E6B0(1, 1);
                      }
                      off_67ED8();
                    }
                    v214 = *(pthread_mutex_t **)(v307 + 0x438);
                    *v301 = 0;
                    if ( pthread_mutex_lock(v214) )
                    {
                      v275 = _errno_location();
                      snprintf(
                        v175,
                        0x800u,
                        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
                        *v275,
                        "cgminer.c",
                        "main",
                        12427);
                      goto LABEL_423;
                    }
                    v215 = *(_DWORD *)(v307 + 0x514);
                    if ( v215
                      && *(int *)(*(_DWORD *)(v215 + 344) + 12) > 1
                      && (v283 = v307,
                          pthread_cond_wait(&stru_744D0, *(pthread_mutex_t **)(v307 + 0x438)),
                          (v284 = *(_DWORD *)(v283 + 0x514)) != 0) )
                    {
                      v285 = *(pthread_mutex_t **)(v283 + 0x438);
                      v286 = *(_DWORD *)(*(_DWORD *)(v284 + 344) + 12);
                      if ( pthread_mutex_unlock(v285) )
                      {
LABEL_422:
                        v271 = _errno_location();
                        snprintf(
                          v175,
                          0x800u,
                          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                          *v271,
                          "cgminer.c",
                          "main",
                          12438);
                        goto LABEL_423;
                      }
                      v216 = off_67ED8();
                      if ( v286 > 1 )
                      {
                        v309 = sub_355FC(0);
                        if ( v309 )
                          sub_2CEA0(&v309, "cgminer.c", "main", 12450);
                        continue;
                      }
                    }
                    else
                    {
                      if ( pthread_mutex_unlock(*(pthread_mutex_t **)(v307 + 0x438)) )
                        goto LABEL_422;
                      v216 = off_67ED8();
                    }
                    if ( v309 )
                      v216 = sub_2CEA0(&v309, "cgminer.c", "main", 12458);
                    v300 = "Selecting pool %d for work";
                    v309 = sub_2FD8C(v216);
                    v217 = pthread_mutex_lock(&mutex);
LABEL_349:
                    v227 = sub_31FF4(v217);
                    v228 = *(_DWORD *)(v307 + 0x3F8);
                    if ( v228 == 4 )
                      break;
                    if ( v228 != 3 )
                      goto LABEL_331;
                    v218 = *v196;
                    v219 = 0;
                    v220 = *(_DWORD **)v212;
                    while ( v219 < v218 )
                    {
                      if ( *(_DWORD *)(v220[v219] + 64) < *(_DWORD *)(v220[v219] + 60) )
                        goto LABEL_360;
                      ++v219;
                    }
                    for ( ii = 0; v218 > ii; ++ii )
                    {
                      v230 = v220[ii];
                      *(_DWORD *)(v230 + 64) = 0;
                    }
                    v231 = *(_DWORD *)&v213[-68] + 1;
                    if ( v218 <= v231 )
                      v231 = 0;
                    *(_DWORD *)&v213[-68] = v231;
LABEL_360:
                    v232 = 0;
                    v233 = v212;
                    while ( 1 )
                    {
                      v239 = v232 + 1;
                      if ( v232 >= *v196 )
                        break;
                      v234 = *(_DWORD *)(*(_DWORD *)v233 + 4 * *(_DWORD *)&v213[-68]);
                      v235 = *(_DWORD *)(v234 + 64);
                      v236 = *(_DWORD *)(v234 + 60);
                      *(_DWORD *)(v234 + 64) = v235 + 1;
                      if ( v235 < v236 )
                      {
                        if ( !*(_BYTE *)(v234 + 97) && *(_DWORD *)(v234 + 100) == 1 && !sub_2B684(v234) )
                        {
                          v212 = v233;
                          v227 = v270;
                          goto LABEL_377;
                        }
                        if ( *v304 )
                        {
                          v237 = sub_2B7BC(0);
                          --*(_DWORD *)(v237 + 64);
                        }
                      }
                      v238 = *(_DWORD *)&v213[-68] + 1;
                      v92 = v238 < *v196;
                      *(_DWORD *)&v213[-68] = v238;
                      if ( !v92 )
                        *(_DWORD *)&v213[-68] = 0;
                      v232 = v239;
                    }
                    v212 = v233;
                    for ( jj = 0; ; ++jj )
                    {
                      if ( jj >= *v196 )
                        goto LABEL_331;
                      v241 = sub_2B7BC(jj);
                      if ( !*(_BYTE *)(v241 + 97) && *(_DWORD *)(v241 + 100) == 1 && !sub_2B684(v241) )
                        break;
                    }
                    v227 = v242;
LABEL_377:
                    if ( !byte_68BD5 )
                      goto LABEL_378;
LABEL_332:
                    if ( *(_BYTE *)v302 || *(_BYTE *)v306 || dword_67DB4 > 6 )
                    {
                      snprintf(v175, 0x800u, v300, *(_DWORD *)v227);
                      sub_20F58(7, v175, 0);
                    }
LABEL_336:
                    if ( *(_BYTE *)(v227 + 97) || *(_DWORD *)(v227 + 100) != 1 )
                    {
LABEL_338:
                      v221 = sub_34178(0);
                      v222 = sub_31FF4(v221);
                      v223 = *(_DWORD *)(v307 + 0x3F8);
                      if ( v223 == 4 )
                      {
                        v222 = sub_2B6A8();
                        goto LABEL_341;
                      }
                      if ( v223 != 3 )
                        goto LABEL_341;
                      v224 = *v196;
                      v225 = 0;
                      v226 = *(_DWORD **)v212;
                      while ( v225 < v224 )
                      {
                        if ( *(_DWORD *)(v226[v225] + 64) < *(_DWORD *)(v226[v225] + 60) )
                          goto LABEL_398;
                        ++v225;
                      }
                      for ( kk = 0; v224 > kk; ++kk )
                      {
                        v258 = v226[kk];
                        *(_DWORD *)(v258 + 64) = 0;
                      }
                      v259 = *(_DWORD *)&v213[-68] + 1;
                      if ( v224 <= v259 )
                        v259 = 0;
                      *(_DWORD *)&v213[-68] = v259;
LABEL_398:
                      for ( mm = 0; ; mm = v262 )
                      {
                        v262 = mm + 1;
                        if ( mm >= *v196 )
                        {
                          for ( nn = 0; nn < *v196; ++nn )
                          {
                            v268 = sub_2B7BC(nn);
                            if ( !*(_BYTE *)(v268 + 97) && *(_DWORD *)(v268 + 100) == 1 && !sub_2B684(v268) )
                              goto LABEL_414;
                          }
LABEL_341:
                          if ( byte_68BD5 )
                            goto LABEL_342;
                          goto LABEL_346;
                        }
                        v263 = *(_DWORD *)(*(_DWORD *)v212 + 4 * *(_DWORD *)&v213[-68]);
                        v264 = *(_DWORD *)(v263 + 64);
                        v265 = *(_DWORD *)(v263 + 60);
                        *(_DWORD *)(v263 + 64) = v264 + 1;
                        if ( v264 < v265 )
                        {
                          if ( !*(_BYTE *)(v263 + 97) && *(_DWORD *)(v263 + 100) == 1 && !sub_2B684(v263) )
                          {
LABEL_414:
                            v222 = v269;
                            if ( !byte_68BD5 )
                              goto LABEL_415;
LABEL_342:
                            if ( *(_BYTE *)v302 || *(_BYTE *)v306 || dword_67DB4 > 6 )
                            {
                              snprintf(v175, 0x800u, v300, *(_DWORD *)v222);
                              sub_20F58(7, v175, 0);
                            }
LABEL_346:
                            if ( !*(_BYTE *)(v222 + 97) && *(_DWORD *)(v222 + 100) == 1 )
                            {
LABEL_415:
                              v217 = sub_2B684(v222);
                              if ( v217 )
                                goto LABEL_348;
                            }
                            else
                            {
LABEL_348:
                              v217 = sub_23B9C(11);
                            }
                            goto LABEL_349;
                          }
                          if ( *v304 )
                          {
                            v266 = sub_2B7BC(0);
                            --*(_DWORD *)(v266 + 64);
                          }
                        }
                        v261 = *(_DWORD *)&v213[-68] + 1;
                        v92 = v261 < *v196;
                        *(_DWORD *)&v213[-68] = v261;
                        if ( !v92 )
                          *(_DWORD *)&v213[-68] = 0;
                      }
                    }
LABEL_378:
                    if ( sub_2B684(v227) )
                      goto LABEL_338;
                    pthread_mutex_unlock(&mutex);
                    if ( *(_BYTE *)(v227 + 640) )
                    {
                      sub_360B0(v227, v309);
                      if ( byte_68BD5 && (*(_BYTE *)v302 || *(_BYTE *)v306 || dword_67DB4 > 6) )
                      {
                        strcpy(v175, "Generated stratum work");
                        sub_20F58(7, v175, 0);
                      }
                      sub_3D93C(v309);
                      v309 = 0;
                      pthread_mutex_unlock(&mutex);
                    }
                    else
                    {
                      pthread_mutex_unlock(&mutex);
                      v300 = *(char **)v303;
                      if ( v300 )
                      {
                        v272 = v309;
                        v273 = v309 + 400;
                        sub_2EA28(v309);
                        v274 = *(_DWORD **)v212;
                        *(_BYTE *)(v272 + 282) = 1;
                        *(_DWORD *)(v272 + 260) = *v274;
                        sub_239A4(v273);
                        sub_257F8(v272 + 408, v273);
                        *(_BYTE *)(v272 + 440) = 66;
                        sub_2B1B0(v272);
                        if ( byte_68BD5 && (*(_BYTE *)v302 || *(_BYTE *)v306 || dword_67DB4 > 6) )
                        {
                          v247 = "Generated benchfile work";
                          v248 = v175;
LABEL_387:
                          v249 = *(_DWORD *)v247;
                          v250 = *((_DWORD *)v247 + 1);
                          v251 = *((_DWORD *)v247 + 2);
                          v252 = *((_DWORD *)v247 + 3);
                          v253 = v247 + 16;
                          *(_DWORD *)v248 = v249;
                          *((_DWORD *)v248 + 1) = v250;
                          *((_DWORD *)v248 + 2) = v251;
                          *((_DWORD *)v248 + 3) = v252;
                          v254 = v248 + 16;
                          v255 = v253[1];
                          v256 = v253[2];
                          *v254 = *v253;
                          v254[1] = v255;
                          *((_BYTE *)v254 + 8) = v256;
                          sub_20F58(7, v175, 0);
                        }
LABEL_388:
                        sub_3D93C(v309);
                        v309 = 0;
                      }
                      else if ( *(_BYTE *)(v307 + 0x5A4) )
                      {
                        v243 = v309;
                        *(_QWORD *)(v309 + 376) = 0x4040000000000000LL;
                        sub_254E8(v243 + 160, &unk_6A950, 32, "cgminer.c", "get_benchmark_work", 4265);
                        v244 = v300;
                        v245 = *(_DWORD **)v212;
                        *(_BYTE *)(v243 + 282) = 1;
                        *(_DWORD *)(v243 + 244) = v244;
                        *(_DWORD *)(v243 + 260) = *v245;
                        sub_239A4(v243 + 400);
                        sub_257F8(v243 + 408, v243 + 400);
                        v246 = (unsigned __int8)byte_68BD5;
                        *(_BYTE *)(v243 + 440) = 66;
                        if ( v246 && (*(_BYTE *)v302 || *(_BYTE *)v306 || dword_67DB4 > 6) )
                        {
                          v247 = "Generated benchmark work";
                          v248 = v175;
                          goto LABEL_387;
                        }
                        goto LABEL_388;
                      }
                    }
                  }
                  v227 = sub_2B6A8();
LABEL_331:
                  if ( !byte_68BD5 )
                    goto LABEL_336;
                  goto LABEL_332;
                }
                while ( *v196 > (int)v197 )
                {
                  v207 = *(_DWORD *)(*(_DWORD *)v300 + 4 * (_DWORD)v197);
                  v182 = v207 + 100;
                  if ( *(_DWORD *)(v207 + 100) != 1 )
                    v182 = sub_2B664(v182);
                  ++v197;
                  *(_BYTE *)(v207 + 97) = 1;
                }
                if ( *(_BYTE *)v195 || *(_BYTE *)v306 || dword_67DB4 > 4 )
                {
                  strcpy(v175, "Probing for an alive pool");
                  v182 = sub_20F58(5, v175, 0);
                }
                v280 = 0;
                sub_2B41C(v182);
                do
                {
                  ++v280;
                  sleep(1u);
                  if ( v280 == 180 )
                    v281 = 0;
                  else
                    v281 = (*(_BYTE *)(v307 + 0x598) ^ 1) & 1;
                }
                while ( v281 );
                v299 = v185;
                v282 = v306;
                while ( 1 )
                {
                  if ( *(_BYTE *)(v307 + 0x598) )
                  {
                    v185 = v299;
                    goto LABEL_284;
                  }
                  if ( v281 )
                    goto LABEL_456;
                  if ( ((*(_BYTE *)v195 || *(_BYTE *)v282 || dword_67DB4 > 2)
                     && ((strcpy(v175, "No servers were found that could be used to get work from."),
                          sub_20F58(3, v175, 0),
                          *(_BYTE *)v195)
                      || *(_BYTE *)v282)
                     || dword_67DB4 > 2)
                    && ((strcpy(v175, "Please check the details from the list below of the servers you have input"),
                         sub_20F58(3, v175, 0),
                         *(_BYTE *)v195)
                     || *(_BYTE *)v282)
                    || dword_67DB4 > 2 )
                  {
                    strcpy(
                      v175,
                      "Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers");
                    sub_20F58(3, v175, 0);
                  }
                  for ( i1 = 0; *v196 > i1; ++i1 )
                  {
                    if ( *(_BYTE *)v195 || *(_BYTE *)v282 || dword_67DB4 > 3 )
                    {
                      snprintf(
                        v175,
                        0x800u,
                        "Pool: %d  URL: %s  User: %s  Password: %s",
                        i1,
                        *(const char **)(*(_DWORD *)(*(_DWORD *)v300 + 4 * i1) + 164),
                        *(const char **)(*(_DWORD *)(*(_DWORD *)v300 + 4 * i1) + 172),
                        *(const char **)(*(_DWORD *)(*(_DWORD *)v300 + 4 * i1) + 176));
                      sub_20F58(4, v175, 0);
                    }
                  }
                  if ( !byte_74488 )
                  {
LABEL_473:
                    strcpy(v175, "No servers could be used! Exiting.");
                    sub_20F58(3, v175, 1);
                    sub_2E6B0(0, 0);
                  }
                  if ( *(_BYTE *)v195 || *(_BYTE *)v282 || dword_67DB4 > 2 )
                    break;
LABEL_457:
                  v281 = 1;
                }
                strcpy(v175, "Press any key to exit, or cgminer will wait indefinitely for an alive pool.");
                sub_20F58(3, v175, 0);
LABEL_456:
                if ( !byte_74488 )
                  goto LABEL_473;
                goto LABEL_457;
              }
              qmemcpy(v313, "All devices disabled, cannot mint!", 34);
              v126 = aAllDevicesDisa[34];
              v127 = (char *)&v313[8] + 2;
LABEL_142:
              *v127 = v126;
              sub_20F58(3, v313, 1);
              sub_2E6B0(1, 0);
            }
            if ( byte_74500 || *(_BYTE *)v306 )
              goto LABEL_112;
            goto LABEL_111;
          }
          goto LABEL_146;
        }
      }
      snprintf((char *)v313, 0x800u, "Log file path: %s Open flag: %s", (const char *)&dword_68AD4, v300);
      sub_20F58(3, v313, 0);
    }
    v114 = *(const char **)(v307 + 0x208);
    if ( !v114 )
    {
      v306 = (const char **)&byte_68BD4;
      goto LABEL_176;
    }
LABEL_146:
    memset(v312, 0, sizeof(v312));
    v128 = *(const char **)(v307 + 0x204);
    if ( v128 )
    {
      if ( !*v128 )
      {
        v146 = "Log work asic num empty";
        v147 = v313;
LABEL_188:
        v148 = *(_DWORD *)v146;
        v149 = *((_DWORD *)v146 + 1);
        v150 = *((_DWORD *)v146 + 2);
        v151 = *((_DWORD *)v146 + 3);
        v152 = v146 + 16;
        *v147 = v148;
        v147[1] = v149;
        v147[2] = v150;
        v147[3] = v151;
        v153 = v147 + 4;
        v154 = v152[1];
        *v153 = *v152;
        v153[1] = v154;
        v155 = v313;
        goto LABEL_189;
      }
      v129 = strtol(v128, 0, 10);
      v130 = v129 == 1;
      if ( v129 != 1 )
        v130 = ((v129 - 32) & 0xFFFFFFDF) == 0;
      *(_DWORD *)&v304[-608] = v129;
      if ( !v130 )
      {
        strcpy((char *)v313, "Log work asic num must be 1, 32, 64");
        sub_20F58(3, v313, 1);
        sub_2E6B0(1, 1);
      }
      v306 = (const char **)&byte_68BD4;
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
      {
        snprintf(
          (char *)v313,
          0x800u,
          "Log work path: %s Asic num: %s",
          *(const char **)(v307 + 0x208),
          *(const char **)(v307 + 0x204));
        sub_20F58(3, v313, 0);
      }
    }
    else
    {
      v306 = (const char **)&byte_68BD4;
      if ( byte_74500 || byte_68BD4 || dword_67DB4 > 2 )
      {
        snprintf((char *)v313, 0x800u, "Log work path: %s", v114);
        sub_20F58(3, v313, 0);
      }
    }
    sprintf(v312, "%s.txt", *(const char **)(v307 + 0x208));
    v131 = fopen64(v312, &word_5406C);
    v132 = (unsigned __int8)byte_74500;
    *(_DWORD *)&v304[-604] = v131;
    if ( v132 || *(_BYTE *)v306 || dword_67DB4 > 2 )
    {
      snprintf((char *)v313, 0x800u, "Log work open file %s", v312);
      sub_20F58(3, v313, 0);
    }
    v133 = *(_DWORD *)&v304[-608];
    if ( v133 == 1 )
    {
      sprintf(v312, "%s%02d.txt", *(const char **)(v307 + 0x208), 1);
      v156 = fopen64(v312, &word_5406C);
      v157 = (unsigned __int8)byte_74500;
      *(_DWORD *)&v304[-600] = v156;
      if ( v157 || *(_BYTE *)v306 || dword_67DB4 > 2 )
      {
        snprintf((char *)v313, 0x800u, "Log work open asic %d file %s", *(_DWORD *)&v304[-608], v312);
        sub_20F58(3, v313, 0);
      }
    }
    else if ( ((v133 - 32) & 0xFFFFFFDF) == 0 )
    {
      format = (char *)&word_5406C;
      v134 = 0;
      v135 = v304;
      while ( 1 )
      {
        v138 = *(_DWORD *)&v135[-608];
        if ( v138 < v134 )
          break;
        sprintf(v312, "%s%02d_%02d.txt", *(const char **)(v307 + 0x208), v138, v134);
        v136 = fopen64(v312, format);
        v137 = (unsigned __int8)byte_74500;
        dword_6A978[v134] = v136;
        if ( v137 || *(_BYTE *)v306 || dword_67DB4 > 2 )
        {
          snprintf((char *)v313, 0x800u, "Log work open asic %d file %s", *(_DWORD *)&v135[-608], v312);
          sub_20F58(3, v313, 0);
        }
        ++v134;
      }
    }
    if ( v304[-340] )
    {
      v139 = &byte_6AA7C;
      v140 = 0;
      format = "Log work open diff file %s";
      do
      {
        sprintf(v312, "%s_diff_%02d.txt", *(const char **)(v307 + 0x208), v140);
        v141 = fopen64(v312, &word_5406C);
        v142 = (unsigned __int8)byte_74500;
        *((_DWORD *)v139 + 1) = v141;
        v139 += 4;
        if ( v142 || *(_BYTE *)v306 || dword_67DB4 > 2 )
        {
          snprintf((char *)v313, 0x800u, format, v312);
          sub_20F58(3, v313, 0);
        }
        ++v140;
      }
      while ( v140 != 65 );
    }
LABEL_176:
    if ( byte_74500 || *(_BYTE *)v306 )
      goto LABEL_178;
    goto LABEL_109;
  }
  v75 = calloc(24 * *(_DWORD *)(v74 + 4), 1u);
  if ( v75 )
  {
    v76 = *((_DWORD *)v36 + 17);
    v77 = v36;
    v303 = 0;
    *(_DWORD *)(v76 + 24) = (((2 * *(_DWORD *)(v76 + 4) - 1) & *(_DWORD *)(v76 + 12)) != 0)
                          + (*(_DWORD *)(v76 + 12) >> (*(_BYTE *)(v76 + 8) + 1));
    *(_DWORD *)(*((_DWORD *)v36 + 17) + 28) = 0;
    v78 = (__int64 *)*((_DWORD *)v36 + 17);
    while ( 1 )
    {
      v79 = *v78;
      if ( *((_DWORD *)v78 + 1) <= (unsigned int)v303 )
        break;
      v80 = *(_DWORD **)(v79 + 12 * (_DWORD)v303);
      if ( v80 )
      {
        do
        {
          v81 = (_DWORD *)v80[4];
          v82 = 3 * ((2 * *((_DWORD *)v78 + 1) - 1) & v80[7]);
          v83 = (char *)&v75[3 * ((2 * *((_DWORD *)v78 + 1) - 1) & v80[7])];
          v84 = *((_DWORD *)v83 + 1) + 1;
          *((_DWORD *)v83 + 1) = v84;
          v85 = *((_DWORD *)v77 + 17);
          if ( v84 > *(_DWORD *)(v85 + 24) )
          {
            v86 = *(_DWORD *)(v85 + 28);
            format = v83;
            *(_DWORD *)(v85 + 28) = v86 + 1;
            v87 = sub_498D8(*((_DWORD *)v83 + 1), *(_DWORD *)(*((_DWORD *)v77 + 17) + 24));
            *((_DWORD *)format + 2) = v87;
          }
          v80[3] = 0;
          v80[4] = v75[v82];
          v88 = v75[v82];
          if ( v88 )
            *(_DWORD *)(v88 + 12) = v80;
          v75[v82] = v80;
          v80 = v81;
          v78 = (__int64 *)*((_DWORD *)v77 + 17);
        }
        while ( v81 );
      }
      ++v303;
    }
    free((void *)v79);
    v36 = v77;
    *(_DWORD *)(*((_DWORD *)v77 + 17) + 4) *= 2;
    ++*(_DWORD *)(*((_DWORD *)v77 + 17) + 8);
    **((_DWORD **)v77 + 17) = v75;
    v89 = (_DWORD *)*((_DWORD *)v77 + 17);
    v90 = v89[7];
    v91 = v89[3];
    v92 = v90 > v91 >> 1;
    if ( v90 <= v91 >> 1 )
      v93 = 0;
    else
      v93 = v89[8];
    if ( v92 )
      ++v93;
    v89[8] = v93;
    v94 = *((_DWORD *)v77 + 17);
    if ( *(_DWORD *)(v94 + 32) > 1u )
      *(_DWORD *)(v94 + 36) = 1;
    goto LABEL_86;
  }
LABEL_184:
  exit(-1);
}
